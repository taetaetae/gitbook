# 4. 오류
- 코드가 실행되는 환경은 불완전하다.
- 오류에 대해 생각할때 구분이 필요
  - 소프트웨어가 작동을 계속할 수 있는 오류
  - 작동을 계속할 합리적인 방법이 없는 오류

## 4.1 복구 가능성
### 4.1.1 복구 가능한 오류
- 일반적으로 시스템 외부의 무언가에 의해 야기되는 오류에 대해서는 대부분 시스템 전체가 표나지 않고 적절하게 처리하기 위해 노력해야 한다.
- 중요한 점은, 시스템 전체를 지칭한다는 점
- 복구 가능한 오류의 예
  - 잘못된 번호를 입력했을때 유효하지 않다는 오류 메시지를 제공
  - 자신의 코드가 의존하는 서비스에 연결할 수 없는 경우 네트워크 연결을 확인하도록 요청해야 함
  - 서비스 사용에 대한 어떤 통계를 기록하는 등의 그다지 중요하지 않는 오류가 발생한다면 계속 실행해도 무방

### 4.1.2 복구할 수 없는 오류
- 개발자가 코드의 어느 부분에서 뭔가를 망쳐놓은 경우
- 이때는 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화 해야한다.
- 이후 이야기 할 신속한 실패(failing fast)와 요란한 실패(failing loudly)의 개념

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다
- 대부분의 오류는 한 코드가 다른 코드를 호출할 때 발생
- 따라서 다음을 신중하게 고려
  - 오류로부터 복구하기를 호출하는 쪽에서 원하는가?
  - 만약 그렇다면 오류를 처리할 필요가 있다는 것을 호출하는 쪽에서는 어떻게 알 수 있을까?
- 코드는 종종 재사용 되고 여러곳에서 호출 되기 때문에 코드의 잠재적 호출자에 대한 가정을 가능한 한 하지 않는것이 좋다.

```java
class PhoneNumber {
    static PhoneNumber parse(String number){
        if (!isValidPhoneNumber(number)) {
            // 에러를 처리하기 위한 코드 <- 프로그램이 복구할 수 있는가?
        }
    } 
}
```
  - 어디서 어떻게 사용되는지 모르면 오류를 복구하기 어렵다.

```java
PhoneNumber getHeadOfficeNumber() {
    return PhoneNumber.parse("01234bbbbb4556");
}
```
  - 이처럼 잘못된 입력값을 하드코딩 해놨다면 프로그래밍 오류다.
  - 복구할 방법이 없다.

```java
PhoneNumber getUserPhoneNumber(UserInput input) {
    return PhoneNumber.parse(input.getPhoneNumber());
}
``` 
  - 입력을 받아 실행될 경우 복구가 가능하다.
  - 사용자의 입력이 잘못되었음을 알리는 오류메세지가 필요하다.

- 자신의 코드가 어떻게 사용되어야 하는지에 대해 스스로에게는 명백해 보일 수 있을지라도 다른사람들에게는 분명하지 않을 수도 있다는 점을 이해해야 한다.
- 코드 계약이 명확해야 하고, 호출하는 쪽에서 함수를 호출하기 전에 입력을 검증하는 쉽고 분명한 방법이 있어야 한다.

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라
- 다른코드가 자신의 코드를 호출할 경우, 호출 시 오류가 발생한다는 것을 사전에 알 수 있는 실질적인 방법이 없는 경우가 많다.
- 그렇기 때문에 오류가 발생할 수 있다는 가능성을 호출하는 쪽에서 확실하게 인지하도록 해야 한다.
- 그렇지 않으면 개발자의 예상과는 다른 결과를 초래하여 사용자가 버그를 마주할 수 있다.

## 4.2 견고성 vs 실패
- 오류가 발생할 때, 다음 중 하나르 선택
  - 실패, 상위 계층으로 전파 하거나 전체 프로그램의 작동을 멈춘다.
  - 오류를 처리하고 계속 진행한다.

### 4.2.1 신속하게 실패해라
- 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것 (+ StackTrace)
- 소프트웨어가 의도치 않게 잠재적으로 위험한 상태가 되는것을 방지
  - 복구할 수 있는 오류 : 호출하는 쪽에서 오류로부터 훌륭하고 안전하게 복구할 수 있는 기회를 최대한 제공
  - 복구할 수 없는 오류 : 개발자가 문제를 신속하게 파악하고 해결할 수 있는 기회를 최대한 제공

### 4.2.2 요란하게 실패해라
- 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는것
- 가장 명백한(그리고 강압적인) 방법은 예외(또는 이와 유사한 것)를 발생시켜 프로그램을 중단되게 하는 것
- 로깅은 다소 약한 효과 (로그 확인 타이밍, 다른 로그와 겹치는 경우)

### 4.2.3 복구 가능성의 범위
- 한 번의 잘못된 요청으로 전체 서버의 동작이 멈추는 것은 바람직 하지 않기에 견고하게 작성해야 한다.
- 오류 발생시 요란하게 실패해야 한다.
- 이 두 목표가 양립하기란 어렵다.
- 오류가 발견되면 기록하고 모니터링 하며 임계치를 벗어날 경우 알림을 준다.

### 4.2.4 오류를 숨기지 않음
- 오류를 숨길 경우 호출하는 쪽에서 오류로부터 복구할수 있는 기회를 없애는 것
- 복구할 수 없는 오류를 숨기면 프로그래밍 오류가 감춰진다.
- 오류를 숨기는 방법 (이러면 안된다.)
  - 기본값 반환 : 오류가 발생했지만 정상처럼 진행
  - 널 객체 패턴 : 기본값과 비슷한 상황. 빈 리스트 같은 것을 리턴
  - 아무것도 하지 않음
    - 반환하지 않고 단지 어떤 작업을 수행하는 경우 오류 발생시 아무것도 안하는 상황
    - 예외를 감싸서 무시
    - 예외를 감싸서 오류만 로깅 (상위로 전파가 되어야 한다.) 

## 4.3 오류 전달 방법
- 명시적인 방법
  - 코드를 호출한 쪽에서 오류가 발생할수 있음을 인지할 수밖에 없도록 
  - 오류에 대한 처리는 호출하는 쪽에 위임
  - 오류를 모르고 넘어갈 수 있는 방법은 거의 없다.
- 암시적 방법
  - 오류를 알리지만 호출하는 쪽에서 그 오류를 신경쓰지 않아도 된다.
  - 문서나 코드를 읽는 등의 적극적인 노력이 필요
- 요란하게 실패할지 아니면 조용히 실패할지가 아니다.
  - 명시적인 기법을 통해 : 알아야 할 경우를 인지하게끔 하기
  - 암묵적인 기법을 통해 : 할 수 있는 것이 아무것도 없는 상황이라면 이런 상황을 처리해야 하는 부담에서 벗어나게 하는것
- 명시적 및 암묵적인 오류 전달 기법

### 4.3.1 요약: 예외
- 예외 : 코드에서 오류나 예외적인 상황이 발생한 경우 이를 전달하기 위한 방법
- 자바는 검사 예외(checked exception)와 비검사 예외(unchecked exception)개념이 있음

### 4.3.2 명시적 방법: 검사 예외(checked exception)
- 호출하는 쪽에서 예외를 인지하도록
- 예외 처리를 위한 코드를 작성하거나 자신의 함수 시그니처에 해당하는 예외 발생을 선언
- IOException, FileNotFoundException 등
- 검사 예외를 사용한 오류 전달
```java
class NegativeNumberException extends Exception { // 명시적 예외
    private final Double erroneousNumber;
    
    NegativeNumberException(Double erroneousNumber) { this.erroneousNumber = erroneousNumber;
    }
    Double getErroneousNumber() {
        return erroneousNumber;
    } 
}

Double getSquareRoot(Double value) throws NegativeNumberException { // 예외가 발생할 수 있음을 선언 필수
    if (value < 0.0) {
        throw new NegativeNumberException(value);
    }
    return Math.sqrt(value);
}
```

- 검사 예외 처리
```java
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    try {
        ui.setOutput("Square root is: " + getSquareRoot(value));
    } catch (NegativeNumberException e) { // 예외 포착 (catch)
        ui.setError("Can't get square root of negative number: " + e.getErroneousNumber());
    }
}
```

- 예외를 시그니처에 선언하지 않거나 얘외처리를 안하면 컴파일 조차 안됨 > 명시적

### 4.3.3 암시적 방법: 비검사 예외(unchecked exception)
- 코드가 예외를 발생시킬 수 있다는 사실을 전혀 모를 수 있다.
- 문서화를 하더라도 코드 계약의 세부 조항이므로 오류를 암시적으로 알리는 방법
- NullPointerException, ClasssCastException 등
- 비검사 예외를 사용한 오류 전달
```java
class NegativeNumberException extends RuntimeException { // 암시적 예외
  private final Double erroneousNumber;

  NegativeNumberException(Double erroneousNumber) {
    this.erroneousNumber = erroneousNumber;
  }

  Double getErroneousNumber() {
    return erroneousNumber;
  }
}

/**
* @throws NegativeNumberException if the value is negative // 문서화
*/
Double getSquareRoot(Double value) {
    if (value < 0.0) { 
        throw new NegativeNumberException(value); // 비검사 예외 발생
    }
    return Math.sqrt(value);
}
```

- 비검사 예외 처리
```java
void displaySquareRoot() {
    Double value = ui.getInputNumber();
    try {
        ui.setOutput("Square root is: " + getSquareRoot(value));
    } catch (NegativeNumberException e) { // 예외 포착 (catch)
        ui.setError("Can't get square root of negative number: " + e.getErroneousNumber());
    } 
}
```

### 4.3.4 명시적 방법: 널값이 가능한 반환 유형
- 널 : 특정값을 계산하거나 얻는 것이 불가능함을 나타내기 위한 효과적이고 간단한 방법
- 언어가 널 안정성을 지원하는 경우 반환될 수 있다는 것을 알리고, 지원하지 않는 경우 옵셔널 반환 유형을 사용
```java
Double? getSquareRoot(Double value) {
    if(value< 0.0){
        return null; // 오류 발생시 널 리턴
    }
    return Math.sqrt(value);
}
```

```java
void displaySquareRoot() {
    Double? squareRoot = getSquareRoot(ui.getInputNumber());
    if (squareRoot == null) { // 강제적으로 확인해야 한다.
        ui.setError("Can't get square root of a negative number"); 
    } else {
        ui.setOutput("Square root is: " + squareRoot);
    } 
}
```

### 4.3.5 명시적 방법: 리절트 반환 유형
- 호출자에게 값을 얻을 수 없음을 알릴 뿐만 아니라 값을 얻을 수 없는 이유까지 알려주면 유용할때 사용
- 언어마다 지원하는 경우가 있고, 지원이 안될경우 번거롭지만 구현해야 함
```java
class Result<V, E> {
    private final Optional<V> value; // 성공시 값
    private final Optional<E> error; // 실패시 오류
    ...
}
```
```java
class NegativeNumberError extends Error {
  private final Double erroneousNumber;
  NegativeNumberError(Double erroneousNumber) {
    this.erroneousNumber = erroneousNumber;
  }
}

Result<Double, NegativeNumberError> getSquareRoot(Double value) { 
    if (value < 0.0) {
        return Result.ofError(new NegativeNumberError(value)); 
    }
  return Result.ofValue(Math.sqrt(value));
}
```

```java
void displaySquareRoot() {
    Result<Double, NegativeNumberError> squareRoot = getSquareRoot(ui.getInputNumber());
    if (squareRoot.hasError()) {
        ui.setError("Can't get square root of a negative number: " + squareRoot.getError().getErroneousNumber());
    } else {
        ui.setOutput("Square root is: " + squareRoot.getValue());
    }
}

```

### 4.3.6 명시적 방법: 아웃컴 반환 유형
- 어떤 일을 하는 동안 오류가 발생할 수 있고 그것을 호출한 쪽에 알리고자 한다면, 함수가 수행한 동작의 결과를 나타내는 값을 반환하도록 함수를 수정
```java
Boolean sendMessage(Channel channel, String message) {
    if (channel.isOpen()) {
        channel.send(message);
        return true; // 결과(성공) 전달
    }
    return false; // 결과(실패) 전달
}
```

```java
void sayHello(Channel channel) {
    if (sendMessage(channel, "hello")) {
        ui.setOutput("Hello sent"); // 성공한 경우
    } else {
        ui.setError("Unable to send hello"); // 실패한 경우
    }
}
```
- 아웃컴이 무시되지 않도록 : 자바의 [@CheckReturnValue](https://www.tabnine.com/code/java/classes/javax.annotation.CheckReturnValue)

```java
@CheckReturnValue
Boolean sendMessage(Channel channel, String message) {
    ... 
}
```

### 4.3.7 암시적 방법: 프로미스 또는 퓨처
- 비동기적으로 실행하는 코드를 작성할때 프로미스(promise)나 퓨처(future)를 반환
- 함수 내에서 오류가 발생하면 프로미스는 거부(reject)되고 그렇지 않으면 값을 리턴한다.
- 오류가 발생하고 프로미스가 거부될 수 있음을 알려면 프로미스를 생성하는 함수의 세부 조항이나 구현 세부 사항을 확인해야 하기 때문에 암묵적 오류 전달 기법이다.
```java
class NegativeNumberError extends Error {
  ...
}

Promise<Double> getSquareRoot(Double value) async { // 비동기 임을 알린다.
    await Timer.wait(Duration.ofSeconds(1));
    if (value < 0.0) {
        throw new NegativeNumberError(value);
    }
    return Math.sqrt(value);
}
```

```java
void displaySquareRoot() {
    getSquareRoot(ui.getInputNumber())
        .then(squareRoot ->
            ui.setOutput("Square root is: " + squareRoot)) // 성공하면
        .catch(error ->
            ui.setError("An error occurred: " + error.toString())); // 실패하면
}
```

### 4.3.8 암시적 방법: 매직값 반환
- 특정 값(-1, 0) 등을 반환하여 오류임을 전달
- 예상을 벗어나는 결과를 가져올 수 있고 버그로 이어질 수 있다.

## 4.4 복구할 수 없는 오류의 전달
- 오류를 복구할 가능성이 없다면 신속하고 + 요란하게 실패해야 한다.
- 오류 메시지는 대개 스택 트레이스나 줄 번호를 제공, 오류가 발생한 위치를 명확하게 알려준다.

## 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달
- 정답은 없지만 무엇보다 팀이 동의한 철학이 다른 어떤 주장보다 중요하다.
- 그렇지 않을 경우 악몽과 같은 상황을 맞이

### 4.5.1 비검사 예외를 사용해야 한다는 주장
- 코드 구조 개선 : 오류 처리 계층에서 일괄 처리에 용이
- 개발자들이 무엇을 할 것인지에 대해서 실용적이여야 함 : 상위 계층까지 전파하는 것에 따른 코드 작업 발생

### 4.5.2 명시적 기법을 사용해야 한다는 주장
- 매끄러운 오류처리 : 오류를 처리하는 타이밍이 명확하다.
- 실수로 오류를 무시할수 없다 : 처리하지 않을 경우 명백히 코드베이스에서 쉽게 노출 된다.
- 개발자들이 무엇을 할 것인지에 대해서 실용적이여야 함 : 어떤 예외가 발생할지 모르고, 당황스러운 두더지 잡기 게임이 될 수 있음

### 4.5.3 필자의 의견: 명시적 방식을 사용하라
- 완전한 문서화는 드물며 개발자가 오류 처리에 대해 확실하게 알기란 거의 불가능 
- 그럼에도 불구하고 팀원들의 협의가 가장 바람직

## 4.6 컴파일러 경고를 무시하지 말라
- 대부분의 컴파일러는 경고를 오류로 여기고 코드가 컴파일 되지 않도록 설정 가능
- 과장되고 엄격해 보일 수 있지만 실제로 매우 유용